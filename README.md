
Техническое задание: PhraseWeaver Telegram Mini App
1. Общее описание проекта
Название: PhraseWeaver Telegram Mini AppТип: Telegram Mini Application для изучения иностранных языковЦелевая аудитория: Изучающие иностранные языкиМаксимальная нагрузка: 20 одновременных пользователей
2. Функциональные требования
2.1. Управление колодами
* Создание колоды
    * Ввод названия колоды
    * Выбор изучаемого языка (из предустановленного списка)
    * Выбор языка перевода (из предустановленного списка)
    * Сохранение в базе данных
* Просмотр колод
    * Список всех созданных колод пользователя
    * Отображение количества карточек в каждой колоде
    * Отображение количества карточек к повторению
2.2. Создание карточек
* Ввод данных
    * Поле для ввода фразы на изучаемом языке
    * Поле для ввода ключевого слова из фразы
    * Кнопка "Обогатить"
* Процесс обогащения
    * Запрос к ИИ API для генерации 5 фраз с ключевым словом в разных склонениях/спряжениях
    * Фразы должны содержать ключевое слово в разных склонениях/спряжениях
    * Автоматический перевод всех фраз
    * Генерация аудио для каждой фразы
    * Поиск и загрузка одного изображения для ключевого слова
* Подтверждение результатов
    * Отображение всех сгенерированных фраз с переводами
    * Кнопки удаления ненужных фраз
    * Предпросмотр изображения
    * Кнопка "Сохранить выбранные"
2.3. Система тренировки
* Типы карточек
    1. Прямые карточки: Фраза на изучаемом языке → ввод перевода -> показывает перевод
    2. Обратные карточки: Фраза на языке перевода → ввод на изучаемом языке -> показывает фразу
* Интерфейс тренировки
    * Отображение карточки с изображением
    * Кнопка воспроизведения аудио
    * Поле ввода ответа
    * Кнопка "Показать ответ"
    * Кнопки оценки: "Снова", "Хорошо", "Легко"
* Алгоритм интервальных повторений (SRS)
    * Расчет следующей даты повторения на основе оценки пользователя
    * Отображение только карточек, готовых к повторению
2.4. Уведомления
* Ежедневные напоминания о тренировке (через Telegram Bot API)
* Уведомления о готовых к повторению карточках
3. Технические требования
3.1. Архитектура
* Frontend: HTML5 + CSS3 + JavaScript (Vanilla JS или легкий фреймворк)
* Backend: Python 3.12 с FastAPI
* База данных: PostgreSQL
* Контейнеризация: Docker + Docker Compose
* Развертывание: Бесплатный сервер (Railway/Render/Fly.io)
3.2. Интеграции
* Telegram Bot API для Mini App и уведомлений
* Бесплатные ИИ API: Google Gemini / DeepSeek / Qwen
* TTS сервисы: Google Text-to-Speech / Edge-TTS
* Поиск изображений: Unsplash API / Pixabay API
3.3. Хранение файлов
* Аудиофайлы: Локальное хранение на сервере + CDN
* Изображения: Кеширование URL или локальное хранение
* Резервные копии: Автоматическое резервное копирование БД
3.4. Безопасность
* Аутентификация: Telegram WebApp initData
* Шифрование: AES-256 для чувствительных данных
* Валидация: Strict input validation
* Rate limiting: По пользователям и IP
3.5. Кеширование
* Redis для:
    * Сессии пользователей
    * Результаты ИИ запросов
    * Аудиофайлы (метаданные)
    * Часто запрашиваемые изображения
4. Схема базы данных
4.1. Таблицы

sql
-- Пользователи
users (
    id SERIAL PRIMARY KEY,
    telegram_id BIGINT UNIQUE NOT NULL,
    username VARCHAR(255),
    language_code VARCHAR(10) DEFAULT 'en',
    created_at TIMESTAMP DEFAULT NOW(),
    last_active TIMESTAMP DEFAULT NOW()
);

-- Колоды
decks (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    source_lang VARCHAR(10) NOT NULL,
    target_lang VARCHAR(10) NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Концепты (ключевые слова с данными)
concepts (
    id SERIAL PRIMARY KEY,
    deck_id INTEGER REFERENCES decks(id) ON DELETE CASCADE,
    keyword VARCHAR(255) NOT NULL,
    image_url TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Фразы
phrases (
    id SERIAL PRIMARY KEY,
    concept_id INTEGER REFERENCES concepts(id) ON DELETE CASCADE,
    original_text TEXT NOT NULL,
    translated_text TEXT NOT NULL,
    audio_url TEXT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Карточки для тренировки
cards (
    id SERIAL PRIMARY KEY,
    phrase_id INTEGER REFERENCES phrases(id) ON DELETE CASCADE,
    card_type VARCHAR(20) NOT NULL, -- 'direct', 'reverse'
    front_text TEXT NOT NULL,
    back_text TEXT NOT NULL,
    interval_days INTEGER DEFAULT 1,
    ease_factor FLOAT DEFAULT 2.5,
    due_date DATE DEFAULT CURRENT_DATE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- История повторений
reviews (
    id SERIAL PRIMARY KEY,
    card_id INTEGER REFERENCES cards(id) ON DELETE CASCADE,
    rating INTEGER NOT NULL, -- 1=again, 2=good, 3=easy
    reviewed_at TIMESTAMP DEFAULT NOW()
);
5. API Endpoints
5.1. Аутентификация
* POST /auth/telegram - Аутентификация через Telegram WebApp
5.2. Колоды
* GET /api/decks - Получить список колод пользователя
* POST /api/decks - Создать новую колоду
* DELETE /api/decks/{deck_id} - Удалить колоду
5.3. Карточки
* POST /api/decks/{deck_id}/enrich - Обогатить фразу
* POST /api/decks/{deck_id}/cards - Сохранить карточки
* GET /api/decks/{deck_id}/cards/due - Получить карточки к повторению
5.4. Тренировка
* POST /api/cards/{card_id}/review - Отправить оценку карточки
* GET /api/decks/{deck_id}/stats - Статистика по колоде
6. Пользовательские сценарии
6.1. Создание новой колоды
1. Пользователь открывает Mini App
2. Нажимает "Создать колоду"
3. Вводит название, выбирает языки
4. Колода создается и отображается в списке
6.2. Добавление карточек
1. Выбирает колоду из списка
2. Нажимает "Добавить карточки"
3. Вводит фразу и ключевое слово
4. Нажимает "Обогатить"
5. Просматривает результаты
6. Удаляет ненужные фразы
7. Сохраняет выбранные
6.3. Тренировка
1. Выбирает колоду с карточками к повторению
2. Нажимает "Тренировка"
3. Видит карточку с изображением
4. Слушает аудио (опционально)
5. Вводит ответ
6. Нажимает "Показать ответ"
7. Оценивает свой ответ
8. Переходит к следующей карточке
7. Нефункциональные требования
7.1. Производительность
* Время отклика API: < 2 секунд
* Время загрузки страницы: < 3 секунд
* Поддержка 20 одновременных пользователей
7.2. Доступность
* Uptime: 99%
* Работа на мобильных устройствах
* Поддержка основных браузеров
7.3. Масштабируемость
* Горизонтальное масштабирование backend
* Балансировка нагрузки
* Оптимизация запросов к БД
8. Ограничения и риски
8.1. Ограничения
* Бесплатные лимиты внешних API
* Ограничения Telegram Mini App
* Ресурсы бесплатного хостинга
8.2. Риски
* Изменения в Telegram Bot API
* Блокировка внешних сервисов
* Превышение лимитов пользователей
8.3. Митигация
* Использование нескольких ИИ провайдеров
* Кеширование результатов
* Graceful degradation функций
* Мониторинг и алерты


План разработки PhraseWeaver Telegram Mini App
Общая стратегия разработки
Подход: Итеративная разработка с MVP и постепенным добавлением функцийПродолжительность: 6-8 недельКоманда: 1 разработчик
Этап 0: Подготовка окружения 
🎯 Цель
Настроить инфраструктуру разработки и создать базовую архитектуру проекта
📋 Задачи
1. Создание структуры проектаphraseweaver-telegram/
2. ├── backend/
3. │   ├── app/
4. │   │   ├── api/
5. │   │   ├── core/
6. │   │   ├── models/
7. │   │   ├── services/
8. │   │   └── utils/
9. │   ├── requirements.txt
10. │   └── Dockerfile
11. ├── frontend/
12. │   ├── src/
13. │   │   ├── components/
14. │   │   ├── services/
15. │   │   ├── styles/
16. │   │   └── utils/
17. │   ├── public/
18. │   └── index.html
19. ├── docker-compose.yml
20. └── README.md
21. Настройка Docker окружения
    * Создать Dockerfile для backend (Python + FastAPI)
    * Настроить PostgreSQL контейнер
    * Добавить Redis для кеширования
    * Создать docker-compose.yml
22. Инициализация backend
    * Установить FastAPI, SQLAlchemy, Alembic
    * Настроить структуру приложения
    * Создать базовые конфигурации
23. Создание Telegram бота
    * Зарегистрировать бота через @BotFather
    * Получить токен и настроить webhook
    * Создать базовый обработчик команд
✅ Критерии готовности
* 		 Проект запускается через docker-compose
* 		 FastAPI отвечает на базовые запросы
* 		 PostgreSQL подключена и работает
* 		 Telegram бот отвечает на команду /start

Этап 1: Аутентификация и базовая структура 
🎯 Цель
Реализовать систему аутентификации через Telegram и создать базовую структуру данных
📋 Задачи
1. Модели базы данныхpython# models/user.py
2. class User(Base):
3.     id: int
4.     telegram_id: int
5.     username: str
6.     language_code: str
7.     created_at: datetime
8. 
9. # models/deck.py
10. class Deck(Base):
11.     id: int
12.     user_id: int
13.     name: str
14.     source_lang: str
15.     target_lang: str
16.     created_at: datetime
17. Аутентификация Telegram WebApppython# services/auth.py
18. def verify_telegram_data(init_data: str) -> dict:
19.     # Проверка подписи Telegram
20.     # Извлечение данных пользователя
21.     pass
22. 
23. # api/auth.py
24. @router.post("/auth/telegram")
25. async def authenticate(init_data: str):
26.     # Создание или получение пользователя
27.     # Возврат JWT токена
28.     pass
29. Базовый frontend
    * HTML страница с Telegram WebApp SDK
    * Инициализация приложения
    * Базовая аутентификация
    * Простой роутинг (может использовать vanilla JS или Alpine.js)
30. API для управления пользователями
    * GET /api/user/profile
    * PUT /api/user/profile
✅ Критерии готовности
* 		 Пользователь может открыть Mini App из Telegram
* 		 Происходит автоматическая аутентификация
* 		 Создается запись пользователя в БД
* 		 Защищенные API endpoints работают с JWT

Этап 2: Управление колодами (Неделя 2)
🎯 Цель
Реализовать создание, просмотр и управление колодами
📋 Задачи
1. Backend для колодpython# services/deck_service.py
2. class DeckService:
3.     async def create_deck(user_id: int, name: str, source_lang: str, target_lang: str)
4.     async def get_user_decks(user_id: int)
5.     async def delete_deck(deck_id: int, user_id: int)
6. 
7. # api/decks.py
8. @router.get("/decks")
9. @router.post("/decks")
10. @router.delete("/decks/{deck_id}")
11. Frontend для управления колодами
    * Страница списка колод
    * Форма создания новой колоды
    * Выбор языков из предустановленного списка
    * Базовая навигация
12. Конфигурация языковpython# core/config.py
13. SUPPORTED_LANGUAGES = {
14.     'en': 'English',
15.     'es': 'Español’б
16.     'pt': 'Português',
17.     'ru': 'Русский',
18.     'pl': 'Polski',
19. }
20. Валидация и обработка ошибок
    * Проверка существования языков
    * Ограничение на количество колод
    * Обработка дублирования названий
✅ Критерии готовности
* 		 Пользователь может создать колоду с выбором языков
* 		 Отображается список созданных колод
* 		 Можно удалить колоду
* 		 Все операции валидируются

Этап 3: Модуль обогащения контента
🎯 Цель
Создать систему обогащения фраз через ИИ API с генерацией аудио и поиском изображений
📋 Задачи
1. Интеграция с ИИ APIpython# services/ai_service.py
2. class AIService:
3.     async def generate_phrases(
4.         keyword: str, 
5.         original_phrase: str, 
6.         source_lang: str, 
7.         target_lang: str
8.     ) -> List[dict]:
9.         # Генерация 5 фраз через Gemini/DeepSeek
10.         # Возврат структуры: [{"original": "...", "translation": "..."}]
11.         pass
12. Сервис синтеза речиpython# services/tts_service.py
13. class TTSService:
14.     async def generate_audio(text: str, language: str) -> str:
15.         # Генерация аудио через gTTS или Edge-TTS
16.         # Сохранение файла и возврат URL
17.         pass
18. Поиск изображенийpython# services/image_service.py
19. class ImageService:
20.     async def find_image(keyword: str) -> str:
21.         # Поиск через Unsplash/Pixabay API
22.         # Кеширование результатов
23.         pass
24. Основной сервис обогащенияpython# services/enrichment_service.py
25. class EnrichmentService:
26.     async def enrich_phrase(
27.         phrase: str, 
28.         keyword: str, 
29.         source_lang: str, 
30.         target_lang: str
31.     ) -> dict:
32.         # Координация всех сервисов
33.         # Возврат полного набора данных
34.         pass
35. API endpoints
    * POST /api/decks/{deck_id}/enrich
    * Асинхронная обработка с WebSocket или Server-Sent Events
✅ Критерии готовности
* 		 Генерируются 5 фраз с ключевым словом
* 		 Создается аудио для каждой фразы
* 		 Находится подходящее изображение
* 		 Все работает асинхронно без блокировки UI

Этап 4: Интерфейс создания карточек 
🎯 Цель
Создать пользовательский интерфейс для ввода фраз, запуска обогащения и подтверждения результатов
📋 Задачи
1. Модели для хранения контентаpython# models/concept.py
2. class Concept(Base):
3.     id: int
4.     deck_id: int
5.     keyword: str
6.     image_url: str
7. 
8. # models/phrase.py
9. class Phrase(Base):
10.     id: int
11.     concept_id: int
12.     original_text: str
13.     translated_text: str
14.     audio_url: str
15. Frontend страница создания
    * Форма ввода оригинальной фразы
    * Поле для ключевого слова
    * Кнопка "Обогатить" с индикатором загрузки
    * Компонент отображения результатов
    * Возможность удаления ненужных фраз
16. Интерактивные компонентыjavascript// components/EnrichmentForm.js
17. class EnrichmentForm {
18.     async enrichPhrase(phrase, keyword) {
19.         // Отправка запроса
20.         // Обновление UI
21.     }
22.     
23.     removePhrase(phraseId) {
24.         // Удаление фразы из списка
25.     }
26.     
27.     saveSelected() {
28.         // Сохранение выбранных фраз
29.     }
30. }
31. Предпросмотр результатов
    * Отображение сгенерированных фраз
    * Воспроизведение аудио
    * Показ найденного изображения
    * Кнопки управления (удалить, заменить изображение)
32. Сохранение данных
    * API для сохранения выбранных фраз
    * Создание концептов и связанных фраз
    * Обновление счетчиков в колодах
✅ Критерии готовности
* 		 Пользователь может ввести фразу и ключевое слово
* 		 Запускается процесс обогащения с индикатором
* 		 Отображаются результаты с возможностью редактирования
* 		 Выбранные фразы сохраняются в БД

Этап 5: Система карточек и SRS алгоритм
🎯 Цель
Реализовать создание тренировочных карточек и алгоритм интервальных повторений
📋 Задачи
1. Модель карточекpython# models/card.py
2. class Card(Base):
3.     id: int
4.     phrase_id: int
5.     card_type: str  # 'direct', 'reverse'
6.     front_text: str
7.     back_text: str
8.     interval_days: int = 1
9.     ease_factor: float = 2.5
10.     due_date: date = today()
11. SRS алгоритмpython# services/srs_service.py
12. class SRSService:
13.     def calculate_next_review(
14.         current_interval: int,
15.         ease_factor: float,
16.         rating: int  # 1=again, 2=good, 3=easy
17.     ) -> tuple[int, float, date]:
18.         # Реализация алгоритма SuperMemo 2
19.         pass
20. Автоматическое создание карточекpython# services/card_service.py
21. class CardService:
22.     async def generate_cards_for_concept(concept_id: int):
23.         # Создание прямых и обратных карточек
24.         # Для каждой фразы в концепте
25.         pass
26. API для тренировки
    * GET /api/decks/{deck_id}/cards/due
    * POST /api/cards/{card_id}/review
    * GET /api/decks/{deck_id}/stats
27. Интеграция с процессом сохранения
    * Автоматическое создание карточек при сохранении концепта
    * Настройка начальных параметров SRS
✅ Критерии готовности
* 		 Карточки автоматически создаются из сохраненных фраз
* 		 SRS алгоритм корректно рассчитывает интервалы
* 		 API возвращает карточки готовые к повторению
* 		 Статистика по колодам обновляется

Этап 6: Интерфейс тренировки 
🎯 Цель
Создать интерактивный интерфейс для прохождения тренировочных сессий
📋 Задачи
1. Frontend компонент тренировкиjavascript// components/TrainingSession.js
2. class TrainingSession {
3.     constructor(deckId) {
4.         this.deckId = deckId;
5.         this.currentCard = null;
6.         this.cards = [];
7.     }
8.     
9.     async loadCards() {
10.         // Загрузка карточек к повторению
11.     }
12.     
13.     showNextCard() {
14.         // Отображение следующей карточки
15.     }
16.     
17.     checkAnswer(userAnswer) {
18.         // Проверка ответа пользователя
19.     }
20.     
21.     submitRating(rating) {
22.         // Отправка оценки и переход к следующей
23.     }
24. }
25. UI элементы тренировки
    * Карточка с изображением концепта
    * Кнопка воспроизведения аудио
    * Поле ввода ответа
    * Кнопка "Показать ответ"
    * Кнопки оценки: "Снова", "Хорошо", "Легко"
    * Прогресс-бар сессии
26. Логика проверки ответов
    * Нормализация текста (удаление лишних пробелов, приведение к нижнему регистру)
    * Мягкая проверка с учетом опечаток (Levenshtein distance)
    * Отображение правильного ответа
27. Завершение сессии
    * Статистика сессии (количество карточек, правильных ответов)
    * Поздравления и мотивирующие сообщения
    * Возврат к списку колод
28. Обработка аудио
    * Интеграция с Web Audio API
    * Кеширование аудиофайлов
    * Fallback для случаев отсутствия аудио
✅ Критерии готовности
* 		 Пользователь может начать тренировку из колоды
* 		 Корректно отображаются карточки всех типов
* 		 Работает ввод и проверка ответов
* 		 SRS обновляется после каждой оценки
* 		 Показывается статистика сессии

Этап 7: Уведомления и полировка
🎯 Цель
Добавить систему уведомлений и улучшить пользовательский опыт
📋 Задачи
1. Telegram Bot для уведомленийpython# services/notification_service.py
2. class NotificationService:
3.     async def send_daily_reminder(user_id: int):
4.         # Отправка напоминания о тренировке
5.         pass
6.     
7.     async def send_review_notification(user_id: int, cards_count: int):
8.         # Уведомление о готовых карточках
9.         pass
10. Планировщик задачpython# scheduler/tasks.py
11. from celery import Celery
12. 
13. @celery.task
14. def send_daily_reminders():
15.     # Отправка уведомлений всем активным пользователям
16.     pass
17. Улучшения UX
    * Анимации переходов между страницами
    * Feedback при действиях пользователя
    * Оптимизация для мобильных устройств
    * Индикаторы загрузки
18. Обработка ошибок
    * Graceful degradation при недоступности внешних сервисов
    * Информативные сообщения об ошибках
    * Retry механизмы для API запросов
19. Оптимизация производительности
    * Кеширование часто запрашиваемых данных
    * Ленивая загрузка изображений
    * Пагинация для больших списков
    * Компрессия статических ресурсов
✅ Критерии готовности
* 		 Пользователи получают ежедневные напоминания
* 		 Уведомления о готовых карточках работают
* 		 Приложение стабильно работает при ошибках внешних API
* 		 UI оптимизирован для мобильных устройств

Этап 8: Развертывание и мониторинг (Неделя 8)
🎯 Цель
Развернуть приложение на продакшн сервере и настроить мониторинг
📋 Задачи
1. Подготовка к продакшену
    * Настройка переменных окружения
    * Конфигурация для продакшена
    * Оптимизация Docker образов
    * Настройка reverse proxy (nginx)
2. Развертывание на Railway/Render
    * Настройка автоматического деплоя из Git
    * Конфигурация базы данных
    * Настройка Redis
    * SSL сертификаты
3. Мониторинг и логированиеpython# monitoring/health.py
4. from fastapi import APIRouter, Depends
5. from sqlalchemy.orm import Session
6. import redis
7. 
8. @router.get("/health")
9. async def health_check():
10.     # Проверка состояния БД, Redis, внешних API
11.     return {"status": "healthy", "timestamp": datetime.now()}
12. 
13. # logging/setup.py
14. import structlog
15. 
16. def setup_logging():
17.     structlog.configure(
18.         processors=[
19.             structlog.processors.TimeStamper(fmt="iso"),
20.             structlog.processors.add_log_level,
21.             structlog.processors.JSONRenderer()
22.         ]
23.     )
24. Backup и восстановление
    * Автоматическое резервное копирование PostgreSQL
    * Синхронизация аудиофайлов с облачным хранилищем
    * План восстановления после сбоев
25. Настройка домена и SSL
    * Регистрация домена (или использование поддомена)
    * Настройка HTTPS
    * Конфигурация Telegram WebApp URL
26. Тестирование на продакшене
    * Smoke тесты всех основных функций
    * Нагрузочное тестирование с 20 пользователями
    * Проверка уведомлений
✅ Критерии готовности
* 		 Приложение доступно по HTTPS URL
* 		 Все функции работают на продакшене
* 		 Настроен мониторинг и алерты
* 		 Telegram бот отправляет уведомления
* 		 Выполнены нагрузочные тесты

Дополнительные задачи и улучшения
🔄 Итерация 2 (После MVP)
1. Расширенная статистика
    * Графики прогресса изучения
    * Статистика по типам ошибок
    * Анализ трудных слов
2. Социальные функции
    * Публичные колоды
    * Возможность поделиться колодой
    * Рейтинги пользователей
3. Продвинутые тренировки
    * Режим "диктант" (только аудио)
    * Тренировка на время
    * Тематические сессии
🚀 Итерация 3 (Масштабирование)
1. Оптимизация для большего количества пользователей
    * Горизонтальное масштабирование
    * CDN для статических файлов
    * Кеширование на уровне приложения
2. Интеграция с другими платформами
    * Экспорт в Anki
    * Синхронизация с мобильным приложением
    * API для сторонних разработчиков
3. Монетизация (необходимо провести мозговой штурм по этому поводу)

Технический стек
Backend
* Framework: FastAPI 0.104+
* Database: PostgreSQL 15+
* ORM: SQLAlchemy 2.0+
* Cache: Redis 7.0+
* Task Queue: Celery + Redis
* Authentication: JWT + Telegram WebApp validation
Frontend
* Core: HTML5 + CSS3 + Vanilla JavaScript
* Styling: Tailwind CSS или собственные стили
* Build: Vite (опционально, для оптимизации)
* WebApp SDK: @twa-dev/sdk
AI & External Services
* AI: Google Gemini API (основной) + DeepSeek (резервный)
* TTS: gTTS или Microsoft Edge TTS
* Images: Pixels API 
* Translation: Google Translate API (если нужен дополнительный перевод)
Infrastructure
* Containerization: Docker + Docker Compose
* Deployment: Railway, Render или Fly.io
* Monitoring: Structlog + встроенные метрики платформы
* Storage: PostgreSQL + локальное хранение файлов

Оценка ресурсов и рисков
💰 Примерная стоимость
* Хостинг: $0-20 (бесплатные тиры)
* База данных: $0-10
* AI API: $5-15 (в зависимости от использования)
* TTS: $0-5
* Images API: $0 (бесплатные лимиты)
* Домен: $1-2/месяц
Итого: $6-52/месяц для 20 активных пользователей
⚠️ Основные риски
1. Превышение лимитов бесплатных API
    * Митигация: мониторинг использования, резервные сервисы
2. Производительность на бесплатном хостинге
    * Митигация: оптимизация кода, кеширование
3. Изменения в Telegram Bot API
    * Митигация: следить за обновлениями, версионирование API
4. Блокировка внешних сервисов
    * Митигация: использование нескольких провайдеров
📊 Метрики успеха
* Технические:
    * Время отклика API < 2 секунд
    * Uptime > 99%
    * Успешность AI запросов > 95%
* Пользовательские:
    * Retention rate > 60% (возврат через неделю)
    * Средняя длительность сессии тренировки > 5 минут
    * Количество созданных карточек на пользователя > 20

Заключение
Этот план обеспечивает поэтапную разработку полнофункционального Telegram Mini App для изучения языков. Основные преимущества подхода:
1. Итеративность - каждый этап дает работающий результат
2. Масштабируемость - архитектура позволяет легко добавлять новые функции
3. Надежность - предусмотрена обработка ошибок и резервные сценарии
4. Экономичность - использование бесплатных сервисов где возможно
После завершения MVP (этапы 1-6) у вас будет полностью рабочее приложение, которое можно запустить для первых пользователей и собрать обратную связь для дальнейшего развития.

Важные моменты: 

1/ необходимо разделить разработку на мелкие шаги и после каждого шага , после каждого шага ты должен уточнять нравиться ли мне и понятно ли мне все!!!!! Т.ю. Мы разрабатываем вместе. Ты опытный разарботчик а я помощник	

2/ сначала идет к реализации первого экрана. После утверждения	второй и тд



